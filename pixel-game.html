<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Penniless Pilgrim - Pixel Art Edition</title>
    <script src="./phaser.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
        body {
            font-family: 'Press Start 2P', 'Courier New', monospace;
            margin: 0;
            padding: 20px;
            background: linear-gradient(45deg, #0f0f23, #1a1a2e, #16213e);
            background-size: 400% 400%;
            animation: retroGradient 8s ease infinite;
            min-height: 100vh;
            color: #00ff41;
            font-size: 8px;
            line-height: 1.6;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        @keyframes retroGradient {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        p {
            margin: 0;
        }
        
        .game-container {
            background: linear-gradient(135deg, #000814, #001d3d);
            border: 4px solid #00ff41;
            border-radius: 0;
            padding: 20px;
            box-shadow: 
                0 0 20px #00ff41,
                inset 0 0 20px rgba(0, 255, 65, 0.1);
            max-width: 1000px;
            width: 100%;
            position: relative;
        }
        
        .game-container::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, #ff006e, #8338ec, #3a86ff, #06ffa5);
            z-index: -1;
            border-radius: 0;
            animation: borderGlow 3s linear infinite;
        }
        
        @keyframes borderGlow {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }
        
        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 16px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
            font-family: 'Courier New', monospace;
        }
        
        .game-area {
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
        }
        
        .phaser-container {
            margin: 0 auto;
            border: none;
            border-radius: 16px;
            max-width: 416px;
            max-height: 416px;
            overflow: hidden;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }
        
        .ui-panel {
            flex: 1;
            min-width: 300px;
        }
        
        .info-box {
            background: linear-gradient(135deg, #001d3d, #003566);
            padding: 15px;
            border: 2px solid #8338ec;
            border-radius: 0;
            margin-bottom: 15px;
            box-shadow: 
                0 0 10px #8338ec,
                inset 0 0 10px rgba(131, 56, 236, 0.1);
            position: relative;
        }
        
        .info-box::before {
            content: '';
            position: absolute;
            top: 5px;
            left: 5px;
            right: 5px;
            bottom: 5px;
            border: 1px solid rgba(131, 56, 236, 0.3);
            pointer-events: none;
        }
        
        .info-box h3 {
            margin-top: 0;
            color: #2c3e50;
            font-size: 1.2em;
            text-align: center;
            margin-bottom: 10px;
        }
        
        .status-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 8px 0;
            padding: 5px 0;
            border-bottom: 1px solid rgba(0,0,0,0.1);
        }
        
        .status-label {
            font-weight: bold;
            color: #34495e;
        }
        
        .status-value {
            color: #2c3e50;
            font-weight: 600;
        }
        
        .tax-display {
            font-size: 18px;
            font-weight: bold;
            color: #e74c3c;
            animation: taxPulse 2s ease-in-out infinite;
        }
        
        @keyframes taxPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        .controls {
            text-align: center;
            margin: 15px 0;
        }
        
        .direction-buttons {
            display: grid;
            grid-template-columns: repeat(3, 80px);
            grid-template-rows: repeat(3, 50px);
            gap: 8px;
            justify-content: center;
            margin: 15px 0;
        }
        
        .direction-btn {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            font-family: 'Courier New', monospace;
        }
        
        .direction-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            background: linear-gradient(135deg, #2980b9, #1f618d);
        }
        
        .direction-btn:disabled {
            background: linear-gradient(135deg, #bdc3c7, #95a5a6);
            cursor: not-allowed;
            transform: none;
        }
        
        .direction-btn.north { grid-column: 2; grid-row: 1; }
        .direction-btn.west { grid-column: 1; grid-row: 2; }
        .direction-btn.east { grid-column: 3; grid-row: 2; }
        .direction-btn.south { grid-column: 2; grid-row: 3; }
        
        .reset-btn {
            background: linear-gradient(135deg, #27ae60, #229954);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            margin: 10px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            font-family: 'Courier New', monospace;
        }
        
        .reset-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        
        .accordion-header {
            padding: 12px;
            cursor: pointer;
            user-select: none;
            transition: all 0.3s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(135deg, rgba(233, 236, 239, 0.9), rgba(248, 249, 250, 0.9));
            border-radius: 8px;
            margin-bottom: 5px;
        }
        
        .accordion-header:hover {
            background: linear-gradient(135deg, rgba(220, 225, 230, 0.9), rgba(235, 240, 245, 0.9));
        }
        
        .accordion-toggle {
            font-size: 1.2em;
            transition: transform 0.3s ease;
            color: #6c757d;
        }
        
        .accordion-toggle.expanded {
            transform: rotate(180deg);
        }
        
        .accordion-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
            background: rgba(248, 249, 250, 0.95);
            border-radius: 0 0 8px 8px;
        }
        
        .accordion-content.expanded {
            max-height: 200px;
        }
        
        .accordion-content ul {
            margin: 0;
            padding: 15px 20px;
            line-height: 1.6;
        }
        
        .accordion-content li {
            margin-bottom: 6px;
            font-size: 0.9em;
        }
        
        .history {
            max-height: 150px;
            overflow-y: auto;
            background: rgba(248, 249, 250, 0.9);
            padding: 10px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            border: 1px solid #dee2e6;
        }
        
        .history::-webkit-scrollbar {
            width: 6px;
        }
        
        .history::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 3px;
        }
        
        .history::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 3px;
        }
        
        .game-over {
            text-align: center;
            padding: 20px;
            background: linear-gradient(135deg, #d4edda, #c3e6cb);
            border: 2px solid #28a745;
            border-radius: 10px;
            margin: 15px 0;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        
        /* Mobile responsive */
        @media (max-width: 768px) {
            .game-area {
                flex-direction: column;
            }
            
            .ui-panel {
                min-width: auto;
                width: 100%;
            }
            
            .direction-buttons {
                grid-template-columns: repeat(3, 70px);
                grid-template-rows: repeat(3, 45px);
            }
            
            .direction-btn {
                font-size: 16px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>üó°Ô∏è PENNILESS PILGRIM üèõÔ∏è</h1>
        
        <div class="game-area">
            <p>
                Your tax total begins at 4, for entering the city. Walk east one block, add 2. Walk west a block, subtract 2. Walk south one block and your total doubles, but you can divide your total for every block walked northward.
</p>
<p>
Can you get to the temple with a zero balance, and without walking the same path twice?
</p>
            </p>
            <div class="phaser-container" id="phaser-game"></div>
            
            <div class="ui-panel">
                <div id="gameOverMessage" class="game-over" style="display: none;">
                    <h3 id="gameOverTitle">Quest Complete!</h3>
                    <p id="gameOverText"></p>
                </div>
                <!-- Tax Rules Accordion -->
                <div class="info-box">
                    <div class="accordion-header" onclick="toggleAccordion()">
                        <h3>‚öñÔ∏è Sacred Tax Laws</h3>
                        <span class="accordion-toggle" id="accordionToggle">‚ñº</span>
                    </div>
                    <div class="accordion-content" id="accordionContent">
                        <ul>
                            <li><strong>üß≠ North:</strong> Divine blessing - Tax √∑ 2</li>
                            <li><strong>üèîÔ∏è South:</strong> Mountain toll - Tax √ó 2</li>
                            <li><strong>üåÖ East:</strong> Sunrise fee - Tax + 2</li>
                            <li><strong>üåÑ West:</strong> Sunset relief - Tax - 2</li>
                        </ul>
                    </div>
                </div>
                
                <!-- Status Panel -->
                <div class="info-box">
                    <h3>üìç Pilgrim Status</h3>
                    <div class="status-item">
                        <span class="status-label">Position:</span>
                        <span class="status-value" id="currentPosition">[0, 4]</span>
                    </div>
                    <div class="status-item">
                        <span class="status-label">Tax Burden:</span>
                        <span id="currentTax" class="tax-display">0</span>
                    </div>
                    <div class="status-item">
                        <span class="status-label">Available Paths:</span>
                        <span class="status-value" id="validDirections">N, E, S, W</span>
                    </div>
                </div>
                
                <!-- Journey Chronicle Accordion -->
                <div class="info-box">
                    <div class="accordion-header" onclick="toggleLogAccordion()">
                        <h3>üìú Journey Chronicle</h3>
                        <span class="accordion-toggle expanded" id="logAccordionToggle">‚ñº</span>
                    </div>
                    <div class="accordion-content expanded" id="logAccordionContent">
                        <div id="travelHistory" class="history">Your pixel quest begins...</div>
                    </div>
                </div>
                
                <!-- Controls -->
                <div class="controls" style="display: none;">
                    <div class="direction-buttons">
                        <button class="direction-btn north" onclick="move('N')" id="btnN" title="North">‚Üë</button>
                        <button class="direction-btn west" onclick="move('W')" id="btnW" title="West">‚Üê</button>
                        <button class="direction-btn east" onclick="move('E')" id="btnE" title="East">‚Üí</button>
                        <button class="direction-btn south" onclick="move('S')" id="btnS" title="South">‚Üì</button>
                    </div>
                    
                    <button class="reset-btn" onclick="resetGame()">üîÑ New Quest</button>
                </div>
                

            </div>
        </div>
    </div>

    <script>
        // Game logic class (same as before but adapted for Phaser)
        class PennilessPilgrim {
            constructor() {
                this.loc = [0, 4];
                this.tax = 4.0;
                this.history = [];
                this.gameOver = false;
                this.traveledStreets = new Set();
            }
            
            addStreet(street) {
                this.history.push(street);
                this.traveledStreets.add(street);
                const parts = street.split(' to ');
                const streetRev = parts[1] + ' to ' + parts[0];
                this.traveledStreets.add(streetRev);
            }
            
            searchStreet(street) {
                const parts = street.split(' to ');
                const streetRev = parts[1] + ' to ' + parts[0];
                return this.history.some(oldStreet => 
                    oldStreet === street || oldStreet === streetRev
                );
            }
            
            outOfBounds(loc) {
                const bounds = [];
                if (loc[0] === 0) bounds.push('W');
                if (loc[0] === 4) bounds.push('E');
                if (loc[1] === 4) bounds.push('N');
                if (loc[1] === 0) bounds.push('S');
                return bounds;
            }
            
            validDirections() {
                const valid = [];
                const possibleStreets = this.directionStreets();
                const forbidden = { N: false, S: false, E: false, W: false };
                
                for (const key in possibleStreets) {
                    if (this.searchStreet(possibleStreets[key])) {
                        forbidden[key] = true;
                    }
                }
                
                for (const key in forbidden) {
                    if (!forbidden[key]) {
                        valid.push(key);
                    }
                }
                
                const outOfBounds = this.outOfBounds(this.loc);
                return valid.filter(dir => !outOfBounds.includes(dir));
            }
            
            directionStreets() {
                const streetN = `[${this.loc[0]},${this.loc[1]}] to [${this.loc[0]},${this.loc[1] + 1}]`;
                const streetS = `[${this.loc[0]},${this.loc[1]}] to [${this.loc[0]},${this.loc[1] - 1}]`;
                const streetE = `[${this.loc[0]},${this.loc[1]}] to [${this.loc[0] + 1},${this.loc[1]}]`;
                const streetW = `[${this.loc[0]},${this.loc[1]}] to [${this.loc[0] - 1},${this.loc[1]}]`;
                
                return { N: streetN, S: streetS, E: streetE, W: streetW };
            }
            
            addTax(dir) {
                switch (dir) {
                    case 'S': this.tax = this.tax * 2; break;
                    case 'N': this.tax = this.tax / 2; break;
                    case 'E': this.tax += 2; break;
                    case 'W': this.tax -= 2; break;
                }
            }
            
            newLocation(dir) {
                switch (dir) {
                    case 'N': this.loc[1] += 1; break;
                    case 'S': this.loc[1] -= 1; break;
                    case 'E': this.loc[0] += 1; break;
                    case 'W': this.loc[0] -= 1; break;
                }
            }
            
            move(dir) {
                if (this.gameOver) return false;
                
                const validDirs = this.validDirections();
                if (!validDirs.includes(dir)) return false;
                
                const possibleStreets = this.directionStreets();
                this.addStreet(possibleStreets[dir]);
                this.addTax(dir);
                this.newLocation(dir);
                
                if (this.loc[0] === 4 && this.loc[1] === 0) {
                    this.gameOver = true;
                } else if (this.validDirections().length === 0) {
                    this.gameOver = true;
                }
                
                return true;
            }
            
            reset() {
                this.loc = [0, 4];
                this.tax = 4.0;
                this.history = [];
                this.gameOver = false;
                this.traveledStreets.clear();
            }
        }

        // Global game instance
        let game = new PennilessPilgrim();
        let phaserGame;
        let gameScene;
        
        // Phaser game configuration
        const config = {
            type: Phaser.AUTO,
            width: 416,
            height: 416,
            parent: 'phaser-game',
            backgroundColor: '#84c669',
            pixelArt: true,
            scene: {
                preload: preload,
                create: create,
                update: update
            },
            scale: {
                mode: Phaser.Scale.FIT,
                autoCenter: Phaser.Scale.CENTER_BOTH
            }
        };
        
        // Phaser scene functions
        function preload() {
            // Load sprite sheets and NEW tileset
            this.load.spritesheet('pilgrim', 'public/guy.png', { 
                frameWidth: 16,  // 16px wide per frame
                frameHeight: 24  // 24px tall per frame
            });
            this.load.spritesheet('tiles', 'public/Tilemap/tilemap_packed.png', { 
                frameWidth: 16,  // 16px per tile
                frameHeight: 16  // 16px per tile
            });
            this.load.spritesheet('cursors', 'public/cursor_map.png', { 
                frameWidth: 16,  // 16px per tile
                frameHeight: 16  // 16px per tile
            });
            
            // Add loading progress feedback
            this.load.on('progress', function (value) {
                console.log('Loading progress: ' + Math.round(value * 100) + '%');
            });
            
            this.load.on('complete', function () {
                console.log('All assets loaded successfully!');
                console.log('New tilemap: 12x11 grid (132 tiles of 16x16)');
            });
            
            this.load.on('loaderror', function (file) {
                console.error('Error loading file:', file.src);
            });
        }
        
        function create() {
            gameScene = this;
            
            // Create tile map
            this.tileMap = [];
            this.useStreetSprites = [];
            this.pilgrimSprite = null;
            this.templeSprite = null;
            
            // Create directional walking animations for 4x4 sprite grid
            // Corrected mapping: Row 0 = Down, Row 1 = Right, Row 2 = Left, Row 3 = Up
            this.anims.create({
                key: 'walk_down',
                frames: this.anims.generateFrameNumbers('pilgrim', { start: 0, end: 3 }), // Row 0
                frameRate: 8,
                repeat: -1
            });
            
            this.anims.create({
                key: 'walk_right',
                frames: this.anims.generateFrameNumbers('pilgrim', { start: 4, end: 7 }), // Row 1
                frameRate: 8,
                repeat: -1
            });
            
            this.anims.create({
                key: 'walk_left',
                frames: this.anims.generateFrameNumbers('pilgrim', { start: 8, end: 11 }), // Row 2
                frameRate: 8,
                repeat: -1
            });
            
            this.anims.create({
                key: 'walk_up',
                frames: this.anims.generateFrameNumbers('pilgrim', { start: 12, end: 15 }), // Row 3
                frameRate: 8,
                repeat: -1
            });
            
            // Initialize the visual game
            createPixelGrid();
            
            // Add click handlers for tiles
            this.input.on('gameobjectdown', handleTileClick);
            
            // Debug: Log that create function completed
            console.log('Game scene created successfully with directional animations!');
        }
        
        // Tile composition system for creating 3x3 block patterns
        const TILE_COMPOSITIONS = {
            // Stone block pattern (using gray stone tiles from tilemap)
            top_left_corner: [
                [96, 111, 112, 98],     // Top row: stone tiles
                [108, 123, 124, 109],  // Middle row: stone tiles  
                [108, 109, 109, 109],  // Middle row: stone tiles  
                [120, 109, 109, 122]   // Bottom row: stone tiles
            ],
            top_right_corner: [
                [96, 97, 97, 98],     // Top row: stone tiles
                [109, 109, 109, 110],  // Middle row: stone tiles 
                [109, 109, 109, 110],  // Middle row: stone tiles   
                [120, 109, 109, 122]   // Bottom row: stone tiles
            ],
            top_middle: [
                [96, 97, 97, 98],     // Top row: stone tiles
                [109, 109, 109, 109],  // Middle row: stone tiles  
                [109, 109, 109, 109],  // Middle row: stone tiles  
                [120, 109, 109, 122]   // Bottom row: stone tiles
            ],
            left_side: [
                [96, 109, 109, 98],     // Top row: stone tiles
                [108, 109, 109, 109],  // Middle row: stone tiles 
                [108, 109, 109, 109],  // Middle row: stone tiles   
                [120, 109, 109, 122]   // Bottom row: stone tiles
            ],
            right_side: [
                [96, 109, 109, 98],     // Top row: stone tiles
                [109, 109, 109, 110],  // Middle row: stone tiles  
                [109, 109, 109, 110],  // Middle row: stone tiles  
                [120, 109, 109, 122]   // Bottom row: stone tiles
            ],
            middle: [
                [96, 109, 109, 98],     // Top row: stone tiles
                [109, 109, 109, 109],  // Middle row: stone tiles
                [109, 109, 109, 109],  // Middle row: stone tiles    
                [120, 109, 109, 122]   // Bottom row: stone tiles
            ],

            bottom_middle: [
                [96, 109, 109, 98],     // Top row: stone tiles
                [109, 109, 109, 109],  // Middle row: stone tiles  
                [109, 109, 109, 109],  // Middle row: stone tiles  
                [120, 121, 121, 122]   // Bottom row: stone tiles
            ],
            bottom_left_corner: [
                [96, 109, 109, 98],     // Top row: stone tiles
                [108, 109, 109, 109],  // Middle row: stone tiles
                [108, 109, 109, 109],  // Middle row: stone tiles    
                [120, 121, 121, 122]   // Bottom row: stone tiles
            ],
            bottom_right_corner: [
                [96, 109, 109, 98],  // Middle row: stone tiles  
                [109, 109, 109, 110],   // Bottom row: stone tiles
                [109, 109, 109, 110],   // Bottom row: stone tiles
                [120, 121, 121, 122]   // Bottom row: stone tiles
            ],
            temple: [
                [53, 54, 55],     // Top row: stone tiles
                [76, 78, 79]
            ],
            street_horizontal: [
                [13],
                [37]
            ],
            street_vertical: [
                [24,26],
            ],
        };
        
        // Function to create a 3x3 tile composition at a specific location
        function createTileComposition(scene, x, y, compositionName, scale = 1, depth = 0, blockRows = 4, blockCols = 4, originX = 0, originY = 0) {
            const composition = TILE_COMPOSITIONS[compositionName];
            if (!composition) {
                console.error('Unknown tile composition:', compositionName);
                return [];
            }
            
            const tiles = [];
            const tileSize = 16 * scale; // 16px base tile size * scale = 48px
            
            for (let row = 0; row < blockRows; row++) {
                for (let col = 0; col < blockCols; col++) {
                    const tileIndex = composition[row][col];
                    const tileX = x + (col * tileSize);
                    const tileY = y + (row * tileSize);
                    
                    const tile = scene.add.sprite(tileX, tileY, 'tiles', tileIndex);
                    tile.setOrigin(originX, originY);
                    tile.setScale(scale);
                    tile.setDepth(depth);
                    
                    tiles.push(tile);
                }
            }
            
            return tiles;
        }

        
        function update() {
            // Game update logic if needed
        }
        
        function createPixelGrid() {
            const blockSize = 64; // Adjusted to fit 240px canvas: (304 - 4*16) / 4 = 48
            const gapSize = 16;   // 1 tile gap between blocks  
            const startX = 16;     // Small offset to center the grid
            const startY = 16;     // Small offset to center the grid
            
            // Clear existing sprites
            if (gameScene.tileMap) {
                gameScene.tileMap.forEach(row => {
                    if (row) {
                        row.forEach(tile => {
                            if (tile) {
                                // Clean up visual tiles if they exist
                                if (tile.visualTiles) {
                                    tile.visualTiles.forEach(vTile => vTile.destroy());
                                }
                                tile.destroy();
                            }
                        });
                    }
                });
            }
            
            if (gameScene.usedStreetSprites) {
                gameScene.usedStreetSprites.forEach(street => street.destroy());
            }
            
            if (gameScene.pilgrimSprite) {
                gameScene.pilgrimSprite.destroy();
            }
            
            if (gameScene.templeSprite) {
                gameScene.templeSprite.forEach(tile => {
                    if (tile) {
                        tile.destroy();
                    }
                })
            }
            
            gameScene.tileMap = [];
            gameScene.streets = [];
            gameScene.usedStreetSprites = [];
            
            // FIRST: Create grid tiles (background layer)
            const layout = [
                ['bottom_left_corner', 'bottom_middle', 'bottom_middle', 'bottom_middle', 'bottom_right_corner'],
                ['left_side', 'middle', 'middle', 'middle', 'right_side'],
                ['left_side', 'middle', 'middle', 'middle', 'right_side'],
                ['left_side', 'middle', 'middle', 'middle', 'right_side'],
                ['top_left_corner', 'top_middle', 'top_middle','top_middle', 'top_right_corner'],
            ]
            for (let y = 0; y < 5; y++) {
                gameScene.tileMap[y] = [];
                for (let x = 0; x < 5; x++) {
                    const pixelX = startX + x * (blockSize + gapSize);
                    const pixelY = startY + (4 - y) * (blockSize + gapSize); // Flip Y coordinate
                    
                    // Create 3x3 tile composition for each block
                    const selectedPattern = layout[y][x]
                    
                    // Create the 3x3 tile composition (scale 3 = 48px blocks)
                    const blockTiles = createTileComposition(gameScene, pixelX, pixelY, selectedPattern, 1, 5);
                    
                    // Create an invisible interactive area over the entire 3x3 block
                    const tile = gameScene.add.rectangle(pixelX + (blockSize / 2), pixelY + (blockSize / 2), blockSize, blockSize, 0x000000, 0);
                    tile.setInteractive();
                    tile.gridX = x;
                    tile.gridY = y;
                    tile.setDepth(1); // Above the visual tiles but below other sprites
                    
                    // Store reference to the visual tiles for cleanup
                    tile.visualTiles = blockTiles;
                    
                    // Check if clickable
                    const direction = getDirectionToCell(x, y);
                    if (direction && !game.gameOver) {
                        // For rectangles, we set fillColor and alpha instead of tint
                        tile.setFillStyle(0xaaffaa, 0.3); // Light green with transparency
                        tile.isClickable = true;
                        tile.direction = direction;
                    } else {
                        // Make rectangle completely transparent when not clickable
                        tile.setFillStyle(0x000000, 0);
                        tile.isClickable = false;
                    }
                    
                    gameScene.tileMap[y][x] = tile;
                }
            }
            
            // SECOND: Create street overlays (middle layer)
            createStreets();
            createPixelStreets();
            
            // THIRD: Create temple (upper layer) - center of bottom-right block
            const templeX = startX + 4 * (blockSize + gapSize) + (16/2); // Center of block
            const templeY = startY + 4 * (blockSize + gapSize) + (16/2); // Center of block
            templeTiles = createTileComposition(gameScene, templeX, templeY, "temple", 1, 10, 2, 3)
            gameScene.templeSprite = templeTiles;
            
            // FOURTH: Create pilgrim sprite (top layer) - center of top-left block
            const pilgrimX = startX + game.loc[0] * (blockSize + gapSize) + (blockSize / 2); // Center of block
            const pilgrimY = startY + (4 - game.loc[1]) * (blockSize + gapSize) + (blockSize / 2); // Center of block
            
            // Create pilgrim sprite with explicit frame (default to facing down)
            gameScene.pilgrimSprite = gameScene.add.sprite(pilgrimX, pilgrimY, 'pilgrim', 0);
            gameScene.pilgrimSprite.setOrigin(0.5, 0.5);
            gameScene.pilgrimSprite.setScale(1); // Scale appropriately for 48px blocks
            gameScene.pilgrimSprite.setDepth(20); // Top layer - above everything
            
            // No idle animation - just show static frame
            
        }
        
        function createPixelStreets() {
            const blockSize = 64; // Adjusted to fit 240px canvas
            const gapSize = 16;   // 1 tile gap between blocks  
            const startX = 16;     // Small offset to center the grid
            const startY = 16;     // Small offset to center the grid
            
            // Horizontal streets
            for (let y = 0; y < 5; y++) {
                for (let x = 0; x < 4; x++) {
                    const streetKey1 = `[${x},${y}] to [${x+1},${y}]`;
                    const streetKey2 = `[${x+1},${y}] to [${x},${y}]`;
                    
                    if (game.traveledStreets.has(streetKey1) || game.traveledStreets.has(streetKey2)) {
                        const streetX = startX + x * (blockSize + gapSize) + blockSize + (gapSize / 2);
                        const streetY = startY + (4 - y) * (blockSize + gapSize) + (blockSize / 2);
                        const street = gameScene.add.sprite(streetX, streetY, 'cursors', 16);
                        street.setOrigin(0.5, 0.5)
                        street.setDepth(10)
                        gameScene.usedStreetSprites.push(street);
                    }
                }
            }
            
            // Vertical streets
            for (let y = 0; y < 4; y++) {
                for (let x = 0; x < 5; x++) {
                    const streetKey1 = `[${x},${y}] to [${x},${y+1}]`;
                    const streetKey2 = `[${x},${y+1}] to [${x},${y}]`;
                    
                    if (game.traveledStreets.has(streetKey1) || game.traveledStreets.has(streetKey2)) {
                        const streetX = startX + x * (blockSize + gapSize) + ( blockSize / 2);
                        const streetY = startY + (4 - y - 1) * (blockSize + gapSize) + blockSize + (gapSize / 2);
                        
                        const street = gameScene.add.sprite(streetX, streetY, 'cursors', 16);
                        street.setOrigin(0.5, 0.5);
                        street.setDepth(10); // Above tiles, below characters
                        gameScene.usedStreetSprites.push(street);
                    }
                }
            }
        }

        function createStreets() {
            const blockSize = 64; // Adjusted to fit 240px canvas
            const gapSize = 16;   // 1 tile gap between blocks  
            const startX = 16;     // Small offset to center the grid
            const startY = 16;     // Small offset to center the grid
            
            // Horizontal streets
            for (let y = 0; y < 5; y++) {
                for (let x = 0; x < 4; x++) {
                    const streetKey1 = `[${x},${y}] to [${x+1},${y}]`;
                    const streetKey2 = `[${x+1},${y}] to [${x},${y}]`;
                    
                    const streetX = startX + x * (blockSize + gapSize) + blockSize;
                    const streetY = startY + (4 - y) * (blockSize) + (blockSize / 2) + gapSize * (3-y);
                        
                    createTileComposition(gameScene, 
                        streetX, 
                        streetY, 
                        "street_horizontal", 
                        1, 
                        5, 
                        2, 
                        1, 
                        0,
                        0,
                    )
                }
            }
            
            // Vertical streets
            for (let y = 0; y < 4; y++) {
                for (let x = 0; x < 5; x++) {
                    const streetKey1 = `[${x},${y}] to [${x},${y+1}]`;
                    const streetKey2 = `[${x},${y+1}] to [${x},${y}]`;
                    const streetX = startX + x * (blockSize + gapSize) + ( blockSize / 2) - gapSize;
                    const streetY = startY + (4 - y - 1) * (blockSize + gapSize) + blockSize;
                    
                    createTileComposition(gameScene, 
                        streetX, 
                        streetY, 
                        "street_vertical", 
                        1, 
                        5, 
                        1, 
                        2, 
                        0,
                        0,
                    )
                }
            }
        }
        
        function handleTileClick(pointer, gameObject) {
            if (gameObject.isClickable && gameObject.direction) {
                move(gameObject.direction);
            }
        }
        
        // Helper functions (same as before)
        function getDirectionToCell(x, y) {
            const currentX = game.loc[0];
            const currentY = game.loc[1];
            const deltaX = x - currentX;
            const deltaY = y - currentY;
            
            if (Math.abs(deltaX) + Math.abs(deltaY) !== 1) return null;
            
            if (deltaX === 1) return 'E';
            if (deltaX === -1) return 'W';
            if (deltaY === 1) return 'N';
            if (deltaY === -1) return 'S';
            return null;
        }
        
        // UI Functions
        function updateDisplay() {
            document.getElementById('currentPosition').textContent = `[${game.loc[0]}, ${game.loc[1]}]`;
            document.getElementById('currentTax').textContent = game.tax.toFixed(1);
            
            const validDirs = game.validDirections();
            const dirEmojis = { N: 'üß≠', S: 'üèîÔ∏è', E: 'üåÖ', W: 'üåÑ' };
            const validDirText = validDirs.length > 0 ? 
                validDirs.map(dir => `${dirEmojis[dir]} ${dir}`).join(', ') : 
                '‚ùå None';
            document.getElementById('validDirections').textContent = validDirText;
            
            ['N', 'S', 'E', 'W'].forEach(dir => {
                const btn = document.getElementById(`btn${dir}`);
                btn.disabled = !validDirs.includes(dir) || game.gameOver;
            });
            
            const historyDiv = document.getElementById('travelHistory');
            if (game.history.length === 0) {
                historyDiv.innerHTML = '<em>Your pixel quest begins...</em>';
            } else {
                const formattedHistory = game.history.map((street, index) => {
                    const parts = street.split(' to ');
                    return `<div style="margin: 3px 0; padding: 2px 0; border-bottom: 1px solid #eee;">
                        <strong>${index + 1}.</strong> ${parts[0]} ‚Üí ${parts[1]}
                    </div>`;
                }).join('');
                historyDiv.innerHTML = formattedHistory;
                historyDiv.scrollTop = historyDiv.scrollHeight;
            }
            
            const gameOverDiv = document.getElementById('gameOverMessage');
            const gameOverTitle = document.getElementById('gameOverTitle');
            const gameOverText = document.getElementById('gameOverText');
            
            if (game.gameOver) {
                gameOverDiv.style.display = 'block';
                if (game.loc[0] === 4 && game.loc[1] === 0) {
                    gameOverTitle.textContent = 'üéâ Pixel Quest Complete!';
                    gameOverText.innerHTML = `
                        <div style="font-size: 1.1em; margin: 10px 0;">
                            üèõÔ∏è You have reached the sacred temple! üèõÔ∏è
                        </div>
                        <div>Final tax burden: <span style="color: #e74c3c; font-weight: bold;">${game.tax.toFixed(1)}</span></div>
                    `;
                } else {
                    gameOverTitle.textContent = '‚ö†Ô∏è Quest Halted';
                    gameOverText.innerHTML = `
                        <div style="font-size: 1.1em; margin: 10px 0;">
                            üö´ Your path is blocked! No more moves available.
                        </div>
                        <div>Final tax burden: <span style="color: #e74c3c; font-weight: bold;">${game.tax.toFixed(1)}</span></div>
                    `;
                }
            } else {
                gameOverDiv.style.display = 'none';
            }
        }
        
        function move(direction) {
            if (game.move(direction)) {
                // Play appropriate directional walking animation
                if (gameScene.pilgrimSprite) {
                    let animationKey;
                    switch(direction) {
                        case 'N': animationKey = 'walk_up'; break;
                        case 'S': animationKey = 'walk_down'; break;
                        case 'E': animationKey = 'walk_right'; break;
                        case 'W': animationKey = 'walk_left'; break;
                        default: animationKey = 'walk_down'; break;
                    }
                    gameScene.pilgrimSprite.play(animationKey);
                }
                
                // Animate pilgrim movement with slower, smoother animation
                const blockSize = 64; // Adjusted to fit 240px canvas
                const gapSize = 16;   // 1 tile gap between blocks  
                const startX = 16;     // Small offset to center the grid
                const startY = 16;     // Small offset to center the grid
                const newX = startX + game.loc[0] * (blockSize + gapSize) + (blockSize / 2); // Center of block
                const newY = startY + (4 - game.loc[1]) * (blockSize + gapSize) + (blockSize / 2); // Center of block
                
                gameScene.tweens.add({
                    targets: gameScene.pilgrimSprite,
                    x: newX,
                    y: newY,
                    duration: 800, // Increased from 300ms to 800ms for slower movement
                    ease: 'Power1', // Smoother easing
                    onComplete: () => {
                        // Stop animation and show static frame facing the direction moved
                        if (gameScene.pilgrimSprite) {
                            gameScene.pilgrimSprite.stop();
                            // Set static frame based on direction (corrected mapping)
                            let staticFrame;
                            switch(direction) {
                                case 'N': staticFrame = 12; break; // Up facing frame
                                case 'S': staticFrame = 0; break;  // Down facing frame
                                case 'E': staticFrame = 4; break;  // Right facing frame (Row 1)
                                case 'W': staticFrame = 8; break;  // Left facing frame (Row 2)
                                default: staticFrame = 0; break;
                            }
                            gameScene.pilgrimSprite.setFrame(staticFrame);
                        }
                        createPixelGrid();
                        updateDisplay();
                    }
                });
            }
        }
        
        function resetGame() {
            game.reset();
            createPixelGrid();
            updateDisplay();
        }
        
        // Accordion functions
        function toggleAccordion() {
            const content = document.getElementById('accordionContent');
            const toggle = document.getElementById('accordionToggle');
            
            if (content.classList.contains('expanded')) {
                content.classList.remove('expanded');
                toggle.classList.remove('expanded');
            } else {
                content.classList.add('expanded');
                toggle.classList.add('expanded');
            }
        }
        
        function toggleLogAccordion() {
            const content = document.getElementById('logAccordionContent');
            const toggle = document.getElementById('logAccordionToggle');
            
            if (content.classList.contains('expanded')) {
                content.classList.remove('expanded');
                toggle.classList.remove('expanded');
            } else {
                content.classList.add('expanded');
                toggle.classList.add('expanded');
            }
        }
        
        // Keyboard controls
        document.addEventListener('keydown', function(event) {
            if (game.gameOver) return;
            
            switch(event.key.toLowerCase()) {
                case 'w':
                case 'arrowup':
                    event.preventDefault();
                    move('N');
                    break;
                case 's':
                case 'arrowdown':
                    event.preventDefault();
                    move('S');
                    break;
                case 'd':
                case 'arrowright':
                    event.preventDefault();
                    move('E');
                    break;
                case 'a':
                case 'arrowleft':
                    event.preventDefault();
                    move('W');
                    break;
                case 'r':
                    event.preventDefault();
                    resetGame();
                    break;
            }
        });
        
        // Initialize Phaser game
        window.addEventListener('load', () => {
            phaserGame = new Phaser.Game(config);
            updateDisplay();
        });
    </script>
</body>
</html>
